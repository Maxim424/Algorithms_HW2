# Algorithms_HW2
Практический анализ алгоритмов поиска вхождений строки-шаблона в тексте

Кузнецов Максим Вадимович. БПИ219

## Основная информация
Код находится в папке `Algorithms_HW2`. Реализованы по критериям 3 алгоритма:
- наивный (naive)
- Кнута-Морриса-Прата с применением стандартных граней (KMP-br)
- Кнута-Морриса-Прата с применением уточненных граней (KMP-brs)

Функции представленных алгоритмов возвращают индекс последнего вхождения шаблона в текст.

Символы подстановки вставляются не подряд, а в различные позиции шаблона.

Замерялось время (в наносекундах) работы этих алгоритмов согласно критериям, результаты замеров находятся в таблицах формата `.csv` в папках `ordinary` (алгоритмы без символа подстановки) и `additional_char` (алгоритмы с символом подстановки). 

Имя каждого файла с таблицами и графиками имеет вид: `219_КузнецовМВ_output_<размер алфавита>_<размер текста>_<количество символов подстановки>`

Каждое значение в таблице получено путем усреднения 10 замеров времени работы того или иного алгоритма.

Графики находятся в папках `charts/ordinary` (алгоритмы без символа подстановки) и `charts/additional_char` (алгоритмы с символом подстановки). Некоторые графики имеют логарифмическую ось Y, чтобы кривые на них не сливались с осью X.

## Сравнение графиков
### Без символов подстановки
- 0 символов подстановки, 10000 символов, бинарный алфавит. На небольших размерах шаблона алгоритмы работают значительно дольше, чем ожидалось. Графики в данном случае напоминают гиперболу. С приближением к размеру шаблона в 3000 символов алгоритмы КПМ начинают проигрывать по времени работы наивному алгоритму. Это можно объяснить тем, что накладные расходы на подсчет массивов граней превышают выигрыш, создаваемый смещением шаблона на несколько позиций относительно текста (а не на одну, как в случае наивного алгоритма)
- 0 символов подстановки, 100000 символов, бинарный алфавит. В этом примере графики показывают эффективность работы алгоритмов КМП по сравнению с наивным алгоритмом. Однако если время работы наивного алгоритма остается примерно одинаковым вне зависимости от длины шаблона, то время работы КМП линейно возрастает. На графике также видно, что КМП на уточненных гранях работает немного быстрее, чем КМП на стандартных гранях
- На оставшихся двух графиках видим, что алгоритмы КМП работают значительно дольше, чем наивных алгоритм, что опять же может быть связано с расходами на подсчет массивов граней.

### С символами подстановки
- При любой из двух представленных длин текста (10000 и 100000 символов) видно, что наивный алгоритм работает значительно лучше, чем КМП. При этом чем больше символов подстановки (их может быть от 1 до 4), тем сильнее видна разница во времени работы. Это объясняется тем, что для адаптации алгоритмов КПМ под условие с символами подстановки был использован перебор всех возможных элементов алфавита (это 2 и 4 элемента) с последующей их подстановкой вместо символа "?". А для адаптации наивного алгоритма под условие требуется лишь одну дополнительную проверку, что на не сильно сказалось на результатах замеров
- Также стоит отметить, что график наивного алогоритма похож на линейный, хотя его асимптотическая сложность равна `O(n * m)`. Это происходит из-за того, что во вложенном цикле срабатывает break в случае, если очередные два элемента (один из текста, а другой из шаблона) не равны. Теоретически мы оценивали худший случай (когда, например, из 100-символьного шаблона 99 символов совпали с 99 символами из текста), при котором инструкция break никак не повлияет на время работы. Однако если из 100-символьного шаблона в среднем будут совпадать с текстом только первые, например, 5 символов, то `m` скорее будет выступать в роли константы и график времени работы алгоритма действительно будет линейным
